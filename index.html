<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>De 7 à 3s : retour d’expérience sur la performance Web sur decitre.fr - AFUP Lyon - 19 avril 2016</title>

        <meta name="description" content="De 7 à 3s : retour d’expérience sur la performance Web sur decitre.fr - AFUP Lyon - 19 avril 2016">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/srogier.css" id="theme">
        <link rel="stylesheet" href="css/font-awesome.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <div class="slides">
                <section>
                    <h1>De 7 à 3s : retour d’expérience sur la performance Web sur decitre.fr</h1>
                    <h3>AFUP Lyon - 19 avril 2016</h3>
                    <a href="https://twitter.com/srogier"><i class="fa fa-twitter"></i>@srogier</a> /
                    <a href="https://github.com/srogier"><i class="fa fa-github"></i> srogier</a>

                    <aside class="notes">
                        Je vais vous présenter aujourd'hui le travail effectué sur la performance Web sur notre site. <br />

                        Lors des deux dernières années sur decitre.fr, nous avons fait la chasse à la seconde côté front (en réduisant et allègeant les ressources exposées) et côté back (notamment avec une migration vers PHP7) afin d’en améliorer l’expérience utilisateur. <br />

                        Je vous parlerai de pourquoi la web performance est important, quelles optimisations ont été faites et les résultats constatés. <br />

                        Nous sommes à un évènement de l’AFUP,  et je suppose que la plupart d’entre vous sont des développeurs PHP. Vous avez l’habitude du backend, de suivre les performances coté PHP.<br />

                        Mais je voulais parler de tout l’aspect performance hors serveur qui pouvait être parfois méconnu de beaucoup d’entre nous. <br />

                        Je ne vous parlerai donc très peu d’optimisations serveur, mais je présenterai tout ce qu’on a pu faire pour accélérer l’affichage de nos pages sur decitre.fr <br />

                    </aside>
                </section>

                <section>
                    <h1>Decitre.fr</h1>
                    <section>
                        <h2>L'équipe</h2>

                        <ul>
                            <li>3 développeurs + 1 responsable technique</li>
                            <li>une dizaine de personnes hors technique</li>
                        </ul>

                        <aside class="notes">
                            Je suis développeur chez Decitre Interactive, au sein d’une équipe technique composée de 4 personnes (3 dev et un responsable technique). <br />

                            éditons decitre.fr, librairie en ligne, basée sur magento. <br />

                            gérons également des versions en MB de notre site, une version B2B, et proposons outil en mode SAAS de recherche bibliographique basé sur du symfony 2. <br />

                            Voilà pour le contexte de l'équipe technique. <br />

                            Autour de nous, on a dizaine de personnes qui interviennent sur le site pour en gérer son contenu, les clients ou bien le SEO.<br />
                        </aside>
                    </section>

                    <section>
                        <h2>Le site</h2>

                        <ul>
                            <li>4,2 millions de pages vues par mois</li>
                            <li>1,3 million de produits</li>
                        </ul>

                        <aside class="notes">
                            Decitre.fr existe depuis 1997. La version actuelle basée sur magento a été mise en ligne en 2012.<br />

                            Pour vous donner une idée du trafic du site, c’est 4,2 millions de pages vues par mois.<br />
                            Quant à notre catalogue produit, on comptabilise 1.3 million de livres et ebooks.<br />

                        </aside>
                    </section>
                </section>




                <section>

                    <section>
                        <h1>Qu'est-ce que la web perfomance ?</h1>

                        <p>Afficher au plus vite son site Internet</p>
                        <aside class="notes">
                            La performance web c'est tout simplement comment afficher au plus vite son site Internet. <br />
                            Historiquement, au début des années 2000 pour les premières règles <br />
                            2007 apparition des yahoo rules for web performance rédigées par Steve Souders. <br />
                            Ce sont 14 bonnes pratiques proposées par ordre d'importance <br />
                            applicables pour tous les sites qui permettent d'améliorer la rapidité d'affichage de son site.<br />
                            Toutes ces pratiques étaient connues avant <br />
                            mais cela a été un des premières compilation de tout cet ensemble de règles.<br />

                        </aside>
                    </section>

                    <section>
                        <h2>L'importance de la performance web</h2>

                        <ul>
                            <li>Corrélation performance technique et performance business</li>
                            <li>Impact sur les nombre de pages, le rebond, la conversion</li>
                        </ul>
                        <aside class="notes">
                            Pourquoi la PW est importante ? pourquoi cherche-t-on à afficher le plus vite possible les pages à nos utilisateurs ? <br />
                            Exemple connus monde du web corréler perf technique et perf business <br />
                            Walmart : 1s de chargement => augmentation du taux de conversion de 2 %; <br />
                            Google : tps chargement + 500ms => baisse de 20% du traffic.  <br />
                            tps de chargement , Influence sur le nombre de page vues, sur le taux de rebond, sur la conversion <br />
                            Critère SEO : google admet vitesse pris en compte dans leur algo de recherche <br />
                        </aside>
                    </section>


                    <section>
                        <h2>Qu’est-ce que le Web ?</h2>

                        <img src="images/osi.jpg">

                        <aside class="notes">
                            On va ressortir des cartons le modèle OSI.  <br />
                            Le web, s'appuie le protocole TCP/IP. <br />
                            C'est à dire, une communication via un réseau physique interfacé avec une couche IP pour l'adressage <br/>
                            TCP qui se charge du transport des données <br />
                            et en haut couche application  retrouve serveur HTTP.  <br />
                        </aside>
                    </section>


                    <section>
                        <h2>Qu’est-ce que le Web ?</h2>

                        <img src="images/client_serveur.jpg">

                        <aside class="notes">
                            Le web, C un système client serveur. <br />
                            navigateur via réseau communique avec serveur backend. <br />
                            Quand on affiche une page, 15 à 20% du temps avant l'affichage complet se passe sur le serveur. <br />
                            80 et 85% du temps consacré au reste ==> cad traitement de la page par le navigateur et le transfert réseau. <br />
                            Avec de telles répartitions, on voit assez bien que pour accélérer sa page, la marge de manoeuvre n'est pas sur le serveur. <br />
                        </aside>
                    </section>

                </section>


                <section>
                    <section>
                        <h1>Optimiser le serveur</h1>

                        <aside class="notes">
                            La partie serveur va donc être assez courte.  <br />
 <br />
                            Quand même vous parler des outils utilisé pour suivre les performances code PHP + grosses optimisations faites. <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Mesurer les performances</h2>

                        <ul>
                            <li>New relic</li>
                            <li>Blackfire</li>
                        </ul>
                        <aside class="notes">
                            Pour commencer, parler des principaux outils que nous utilisons pour suivre développements PHP.<br />
                            New Relic suivre tout ce qui se passe sur nos serveurs. <br />
                            outil de monitoring applicatif le plus utilisé. <br />
                            Retrouvons dedans toutes les erreurs applicatives, les temps de réponse, requêtes et pages lentes, évolution du trafic, le tout historisé. <br />
                            Très bon outil pour suivre évolution mode macro sur quelques mois  <br />
                            mais aussi avoir aperçu ce qui se passe pendant laps de temps très court lorsqu rencontre des pics de charge. <br />
                            Pour rentrer plus dans le détail et suivre nos optimisations de code PHP, nous utilisons Blackfire. <br />
                            Je pense que vous connaissez tous, outil qui permet profiler dans le détail le temps, la mémoire consommée par nos scripts php pour identifier les appels les plus consommateurs. <br />
                            C'est un outil qu'on utilise surtout phase de dév lorsque effectuons nos modifications, pour s'assurer pas de régression de performance.<br />
                        </aside>
                    </section>

                    <section>
                        <h2>Migrer vers PHP 7</h2>

                        <ul>
                            <li>Pas encore fait en prod</li>
                            <li>optimisation du temps de traitement entre 20% et 40% </li>
                        </ul>
                        <aside class="notes">
                            Le sujet du moment dans le monde PHP : PHP 7 et gains de perf promis avec cette nouvelle version. <br />

                            Pour ceux que ça intéresse, Julien Pauli présentera comparatif des performances de PHP 5 vs PHP 7 au PHPTour à Clermont Ferrand. <br />

                            Pour ceux qui étaient ici aux lightning d'il y a mois, tenté de vous vendre la migration à PHP7. <br />
                            Malheureusement, chez nous elle n'est pas encore effectuée.<br/>

                            Nous sommes en train de préparer des serveurs, c’est donc un question de jours/semaines avant que la migration soit faite. <br/>
                            Sauf suprise j’aurais des chiffres pour le PHPTour.<br/>

                            Sur preprod, constat que pages étaient + rapide de l'ordre de 20 à 40%. <br/>
                            Les chiffres valent ce qu'ils valent : env avec peu de trafic, donc attention.<br/>
                            Mais globalement on est dans les valeurs attendues. Donc attendons la mise en prod.  <br />
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>L'importance du réseau</h1>

                        <img src="images/bande_passante.png">

                        <aside class="notes">

                            Pour que navigateur et serveur communiquent , passage réseau (partie basse vue dans modèle OSI de tout à l’heureà. <br />
                            Souvent quand on pense réseau, on va penser bande passante. <br />
                            Bande passante : capacité à transmettre des données pendant un temps. <br />
                            On peut penser que + elle sera élevée, plus notre page va se télécharger rapidement, <br />
                            Mais comme on peut le voir sur le graphique, l'amélioration ne dure qu'un temps : la bande passante n'est plus le goulot d'étranglement.<br />
                        </aside>
                    </section>


                    <section>
                        <h2>L'importance du réseau</h2>

                        <img src="images/latence.png">

                        <aside class="notes">
                            Prise en compte un second critère : la latence. <br />
                            Délai nécessaire pour que les paquets fasse A/R entre le navigateur et le serveur. <br />
                            Temps qui va principalement dépendre du réseau sur lequel vous vous trouvez (mobile, connexion 3G entre 100 et 500ms, fixe  général inférieure à 20 ms)<br />
                            La distance physique entre le navigateur et le serveur influe également. <br />
                            Prend en compte le temps qu'il faut au signal pour passer de l'un à l'autre : + on est loin, plus la latence va être importante. <br/>
                            raison pour lesquelles utiliser un CDN est avantageux. Votre contenu est dupliqué sur des serveurs répartis tout autour du monde. Contenu servi par le serveur le + proche pour limiter l'impact de la latence. <br />

                           tester très facilement impact latence dans outils de développement de votre navigateur. Réglage seuils de bande passante et de latence pour en visualiser l'impact. <br />
                           Sur mac, paramétrer dans options de connexion. <br />
                           Donc pour minimiser l'impact de la latence, on a deux possibilités : soit on rapproche navigateur et serveur pour en réduire la valeur, soit on réduit le nombre de requête serveur pour en réduire la quantité. <br />

                        </aside>
                    </section>


                    <section>
                        <h2>Anatomie d’un hit HTTP</h2>

                        <img src="images/waterfall.png">

                        <aside class="notes">
                            Quand on consulte une page, navigateur récupère la page HTML et les fichiers associées. <br />
                            Visible onglet network navigateurs. <br />
                            Obtient liste des tous les éléments chargés, la page, les feuilles de styles, les scripts, les images, etc. dont notre page a besoin, le moment où ils sont chargés, combien de temps ce chargement a mis. <br />

                            On va rentrer dans le détail d'un des hits HTTP pour voir plus précisément ce qui se passe. <br />

                        </aside>
                    </section>


                    <section>
                        <h2>Anatomie d’un hit HTTP</h2>

                        <img src="images/timing_hit_http.png">

                        <aside class="notes">
                            1. 3 1ere lignes Temps d'attente avant envoi (restriction navigateur) <br />
                            2. Requete DNS. indentification du serveur si on connu<br />
                            3. Etablissement de la connexion. Retombe sur les parties basses du modèle OSI de tout à l'heure<br />
                            3.bis au besoin négo TLS, cf ligne SSL<br />
                            4. connexion établie : envoi de la requete
                            5. le serveur (traite, prépare contenu). attente du premier paquet reçu par le nav : TTFB<br />
                            5. Téléchargement <br />

                            Pour visualiser ces informations, vous pouvez également utiliser webpagetest.org. <br />
                            URL + lieu physique test joués + nav + eventuellement réseau (BP + latence). <br />
                            Attente qq sec le tps que le test s'éxécute (2 waterfall 1er hit et impact cache)<br />
                            Installable sur infra pour tests urls dev + privées <br />
                        </aside>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Faire moins de requêtes</h1>

                        <aside class="notes">
                            Sur cet exemple, entre recherche DNS, l'établissement de la connexion, l'envoi de la requête et son téléchargement, on va évidemment faire appel au réseau.
                            à chaque A/R serveur nous serons confrontés aux problèmes de latence. <br />
                            Je vais donc vous montrer ce qu'on a fait pour réduire le nombre de requêtes vers le serveur.  <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Supprimer les images inutiles</h2>

                        <div class="span6">
                            <div>Image moche</div>
                        </div>
                        <div class="span6">
                            <div>Code HTML bouton moche</div>
                        </div>

                        <aside class="notes">

                            Donc l'objectif, c'est de charger moins de ressources. Pour commencer autant s'attaquer à toutes les images chargées inutilement dans notre CSS.<br />
                            Environ 20 images sur la home chargées dans la CSS. <br />
                            Mise en forme du footer, barre de recherche, mini panier.<br />
                            Présentation des modifications effectuées pour réduire ces appels.  <br />

                            Parenthèse historique : souhait de compat et de rendu similaire IE7 -> chrome dernière version. de google chrome. L’intention était louable, mais en pratique cela peut tourner au drame. <br />

                            Voici le code d'un bouton. catastrophe : structure HTML complexe, tas énorme de CSS et une image à charger pour les coins arrondis. <br />

                            Et ce sur tous les types de boutons que notre site pouvait utiliser. Je vous laisse imaginer tous les problèmes de maintenance liés. <br />

                            Refonte avec de la CSS 3 : gradient et border-radius. <br />
                            suppression désagréable effet de clignotement visible au premier chargement et surtout plus d'images à télécharger <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Utiliser des sprites</h2>

                        <ul>
                            <li>Concaténation d'images en une seule</li>
                            <li>1 seul hit HTTP</li>
                        </ul>


                        <aside class="notes">

                            Point positif à retirer de nos anciens boutons, c’est qu’ils utilisaient une sprite. <br />
                            Pour définir ce qu'est une sprite : technique consiste assembler plusieurs images en une seule<br />
                            équivalent de la concaténation de fichier pour les images <br />
                            L’avantage un seul appel réseau pour charger plusieurs éléments regroupés. <br />
                            On applique l'image sur elt HTML via CSS : sprite en background image + position pour afficher l'élément souhaité <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Utiliser des font d'icônes</h2>

                        <img src="images/sprite.png">

                        <ul>
                            <li>1 fichier (100 icônes) VS plusieurs sprites</li>
                            <li>Poids faible : 16 Ko</li>
                        </ul>

                        <aside class="notes">
                            Par contre, il y a certains éléments pour lesquels les sprites existantes ne nous intéressaient pas.<br />
                            Prenons l'exemple de cette image  <br />
                            Bonne nouvelle, on n'a pas 4 images mais une seule <br/>.
                            Par contre, pictogrammes tout simple (loupe, panier, logo, etc.) fond bleu dégradé faisable CSS. <br />

                            Pour ces images là : choix d'utiliser des font-icônes. <br />
                            Un fichier svg par icone, tache qui compiles cvgs en font utilisables sur le site. <br />

                            Remplacement de plusieurs sprites, ici chargement d'un seul fichier font permet avoir centaines icones chargées. <br />
                            Le tout pour une taille raisonnable (fichier font 16 Ko poour comparer l'image de 4 icônes 2 Ko) <br />

                            Au final sur decitre.fr, on utilise peu de sprites. La quasi totalité de nos pictogrammes sont disponibles dans la font d'icônes.  <br />

                        </aside>

                    </section>


                    <section>
                        <h2>Utiliser les Data URI</h2>

                        <div>
                            <pre>
                                <code data-trim data-noescape>
.reduction {
  background-image: url('bon_reduction.png');
}
                                </code>
                            </pre>
                        </div>
                        <div>
                            <pre>
                                <code data-trim data-noescape>
.reduction {
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEU....');
}
                                </code>
                            </pre>
                        </div>



                        <aside class="notes">
                            Enfin, nous avions des petites images que nous utilisions fréquement, <br />
                            plutôt que faire un hit HTTP, nous les avons directement intégré dans la CSS ou le code HTML.   <br />

                            Comment vous pouvez le voir, au lieu de mettre l'URL de l'image, nous avons mis sa data-URI.   <br />
                            On économise ainsi un hit HTTP.  <br />

                        </aside>
                    </section>

                    <section>
                        <h2>Exemple concret avec le footer</h2>


                        <div class="span6">
                            <div>Avant</div>
                            <img src="images/footer/avant_image.png">
                        </div>
                        <div class="span6">
                            <div>Après</div>
                            <img src="images/footer/apres.png">
                        </div>

                        <aside class="notes">

                            exemple le plus visuellement parlant du travail sur images est ce que nous avons fait sur notre footer. <br />
                            Voici le pied de page tel qu'il était affiché il y a encore quelques mois. <br />
                            En rouge images spécifiquement utilisées pour ce bloc. <br />
                            en tout plus de 10 images utilisées pour ce footer.<br />
                            Voici ce que nous avons fait pour le remplacer en utilisant les différentes techniques dont je viens de parler. <br />
                            On a refait un peu le design et toujours en rouge, on retrouve les différentes images sur la nouvelle. <br />
                        </aside>
                    </section>


                    <section>
                        <h2>Exemple concret avec le footer</h2>

                        <img src="images/footer/graph.png">

                        <aside class="notes">

                            Pour finir le comparatif, deux webpage tests avant et après changement. <br />
                            Non seulement, nettoyage permis d'avoir à un moindre coût un footer plus moderne, <br />
                            mais aussi avons pu faire économie d'un certain nombre d'appel serveurs et accélerer l'affichage de nos pages.<br />

                        </aside>
                    </section>


                    <section>
                        <h2>Gérer le cache</h2>

                        <ul>
                            <li>Cache HTTP</li>
                            <li>Durée de validaté configurable</li>
                        </ul>

                        <aside class="notes">
                            Lorsqu'il télécharge fichier, navigateur a possibilité de mettre de côté pour le réutiliser un peu plus tard s'il est utilisé ailleurs. <br />
                            C'est ce qu'on appelle le cache HTTP. <br />
                            Permet de limiter les allers retours entre le serveur et le navigateur en stockant côté utilisateur des ressources réutilisables.  <br />
                            Chez nous, On défini le mécanisme de cache via l'entête HTTP Cache-Control. <br />

                            En fonction du type de page (recherche, FP, cat), règle ensuite durée de validité avec une valeur allant de qq minutes à une heure. <br />
                            Pour les images, durée de mise en cache + importante et monte à qq heures.  <br />
                            Quant aux assets js/css, là on utilise une valeur de cache beaucoup plus importante.  <br />
                            Pour ces fichiers, les urls uniques et évoluent en fonction contenu ==>  durée de cache peut être en théorie illimitée.  <br />
                        </aside>
                    </section>


                    <section>
                        <h2>Garder les connexions ouvertes</h2>

                        <ul>
                            <li>Utiliser le Keep-Alive</li>
                            <li>Configurer la durée d'ouverture</li>
                            <li>Attention à ne pas saturer les serveurs</li>
                        </ul>

                        <aside class="notes">
                            On a vu tout à l'heure qu'à chaque fois que le navigateur récupèrait un fichier, il établissait une connexion. <br />

                            Côté serveur, peut spécifier directive qui s'appele Keep-Alive ==> permettre de garder ouverte connexion pendant un temps donné. <br />

                            Ainsi, navigateur lorsqu'il va demander une ressource sur domaine où la connexion déjà ouverte, pourra la réutiliser <br />
                            au lieu d'en ouvrir une autre, ce qui nous économisera des allers/retours réseaux d'intialisation de connexion. <br />

                            Paramètre qui se règle sur votre serveur web et sur lequel vous réglez la durée d'ouverture de la connexion. <br />

                            juste faire attention à ne pas affecter une valeur trop importante sur le KA <br />
                            risque d'avoir effet inverse et saturer les serveurs en gardant trop longtemps les connexions ouvertes. <br />

                            pouvez analyser les temps nécessaires à la récupération de vos fichiers pour estimer quelle valeur appliquer sur vos sites.  <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Garder les connexions ouvertes</h2>

                        <img src="images/slow_start.jpg">


                        <aside class="notes">
                            profite du Keep Alive pour parler mécanisme de TCP : le Slow Start <br />

                            TCP connait pas débit optimal connexion, ==> essayer de l'atteindre en augmentant le débit jusqu'à ce que des paquets soit perdus et que le réseau n'absorbe plus le débit. <br />

                            Slow Start TCP : algorithme qui va permettre d'augmenter graduellement le débit. <br />

                            Chaque fois  le serveur reçoit un ACK (confirmation de réception de paquet), le Slow Start va doubler la fenêtre de congestion (le nombre de paquets à transmettre).  <br />

                            L'intérêt réutiliser la connexion et KeepAlive ==> s'épargner le Slow Start nouvelle connexion + profiter d'une fenêtre de congestion avec une forte valeur.  <br />

                            En complément, slow start restart : régler serveur pour que TCP ne réinitialise pas fenêtre la connexion est mise en attente. <br />
                        </aside>

                    </section>

                    <section>
                        <h2>Concaténer les assets</h2>

                        <aside class="notes">
                            Je ne vous apprends rien en vous disant qu'il y a bcp de fichier js et CSS <br />
                            chez nous, 10 css et 70 js  <br />
                            Comme on l'a vu tout à l'heure charger ces fichiers un par un serait catastrophique pour les performances réseaux. <br />
                            On va donc concaténer ensemble tous fichiers javascripts et tous fichiers CSS <br/>
                            éviter les AR inutiles entre le client et le serveur. <br />
                            Pour beaucoup ici, pratique triviale et évidente. <br />
                            Mais dans un écosystème tel que magento, une option configurable dans le back office. <br />
                            signifie que sites peuvent partir en prod sans se soucier d'avoir allégé le nombre de ressources appelées. <br />
                        </aside>
                    </section>


                    <section>
                        <h2>Lazy-loader les images</h2>

                        <ul>
                            <li>Charger ce qui est affiché</li>
                        </ul>


                        <aside class="notes">
                            On a supprimé les images inutiles plus tôt, mais il en reste encore beaucoup. <br />

                            Charge donc plein d'images qui pour certaines d'entre elles sont trop bas dans la page et ne seront jamais affichées.<br />
                            C'est dommage, c'est du chargement inutile. <br />

                            Pour résoudre problématique mis en place mécanisme sur visuels : le lazy loading. <br />

                            Pour ceux qui ne connaissent pas, technique qui consiste à décaler chargement d’une ressource au moment où on en a vraiment besoin. <br />
                            Pour visuels, revient à ne charger les images qu’à partir du moment où elles sont dans le viewport, CAD dans zone visible par l'utilisateur. <br />

                            temps de chargement initial de la page réduit et images ne sont chargées que si elles sont affichées par l’utilisateur.

                        </aside>
                    </section>


                    <section>
                        <h2>Lazy-loader les images</h2>

                        <img src="images/graph_lazy_load.png">

                        <aside class="notes">

                            graphique qui réprésente le nb de requête (en jaune). <br />

                            Comme vous pouvez le contaster on a réduit le nombre de ressources chargées.  <br />

                            Dans le cas des images de notre FP, permis d'économiser une vingtaine d'A/R avec le serveur. <br />

                            En terme de temps de réponse, indicateurs de temps de chargement utilisateurs remontés dans GA indique passage de 4.80s à 4.10s, <br />
                            ce qui est une de plus grosses optimisations effectuées sur le site. <br />
                        </aside>
                    </section>





                </section>

                <section>
                    <section>
                        <h1>Alléger les ressources</h1>

                        <aside class="notes">
                            Je viens de vous présenter ce que nous avons fait pour charger moins de ressources sur notre site et réduire les allers retours avec le serveur.

                            Maintenant, je vais vous parler de ce que nous avons fait pour alléger les requêtes restantes.
                        </aside>
                    </section>


                    <section>
                        <h2>Compresser le contenu</h2>

                        <ul>
                            <li>Activer la compression gzip</li>
                            <li>Diminution de la bande passante</li>
                            <li>Facteur 5 de compression</li>
                        </ul>


                        <aside class="notes">
                            Une des modifications qu’on a fait dès le début pour alléger les ressources a concerné la compression des ressources livrées. <br />
                            Allégèment des fichiers retournés par le serveur. Activation compression gzip. Effet visible dans GA. <br />
                            Non seulement, ressources moins lourdes à charger<br />
                            Quota de bande passante : des données moins lourdes qui transitent. <br />
                            Pertinent pour les fichiers de type texte. Image déjà optimisée <br />
                            Page d'accueil (html + css + js) 1 Mo après gzip 200Ko. <br />
                        </aside>
                    </section>


                    <section>
                        <h2>Minifier les assets</h2>

                        <ul>
                            <li>Suppression des caractères inutiles, simplification du code</li>
                            <li>Pas en place chez nous</li>
                        </ul>

                        <aside class="notes">
                            Après la concat des CSS et JS, bonne pratique suivante : minification <br />
                            Suppression des caractères inutiles (espaces, tab), commentaires, simplification des noms de variables pour le JS.  <br />
                            Permet d'avoir des versions allégées en prod <br />
                            Pas mis en place chez nous. Cout de mise de place de la couche supplémentaire pas assez rentable par rapport aux autres modifications possibles pour le même temps. <br />
                            // TODO chiffrer gain potentiel
                        </aside>
                    </section>

                    <section>
                        <h2>Utiliser des domaines cookieless</h2>


                        <ul>
                            <li>Alléger les requêtes HTTP</li>
                            <li>Création d'un domaine sans cookies pour livrer les images</li>
                        </ul>

                        <aside class="notes">
                            Egalement travail sur  l'optimisation des requêtes serveur pour les ressources statiques. <br />
                            On a tous des cookies sur nos sites Internet.<br />
                            Chaque hit sur le domaine du cookie ==> envoi du cokie. ==> coût car il faut uploader le cookie. <br />
                            Dans le cas de fichiers statiques comme les images ou les feuilles de style, quel intérêt a-t-on à transmettre les cookies utilisateurs ? Aucun. <br />
                            Autre domaine di-static pour servir ces ressources. Cookies liées à decitre.fr donc non envoyé. <br />
                            Requete allégée. Appréciable mobile upload faible. <br />

                        </aside>
                    </section>

                    <section>
                        <h2>Optimiser les images</h2>

                        <ul>
                            <li>Sensibiliser sur les risques</li>
                            <li>Intégrer un outil pour optimiser</li>
                            <li>Nettoyage de nos images</li>
                        </ul>


                        <aside class="notes">
                            J'ai beaucoup parlé d'image un peu plus tôt et du travail qui avait été fait pour en réduire le nombre. <br />
                            Autre problème concernant le poids. <br />
                            Un jour, se retrouve avec images qui font un 1/2 Mo sur page d'accueil <br />
                            Qu'avons nous fait pour empêcher cela ? <br />
                            Sensibiliser différentes équipes qui interviennent sur le site <br />
                            Si on n'explique pas risques liés au poids des images et ce que cela implique pour nos clients ==> on ne peut s'en prendre qu'à nous mêmes <br />
                            PNG et jpeg sont des formats où les images sont compressées, mais souvent pas de manière optimale pour le web.  <br />
                            Présentation d'un outil en ligne pour compresser les images comme tinypng. Chiffre à l'appui pour montrer l'importance et la nécessité de l'étape.<br />
                            Nettoyage côté dev sur les images du dépot sur lesquelles nous ne nous étions jamais penchés. <br />
                            Nettoyage permis diviser taille de toutes les images stockées, passage de 4Mo à 2 Mo.  <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Nettoyer le code mort</h2>

                        <ul>
                            <li>15% de CSS morte</li>
                        </ul>

                        <aside class="notes">

                            Jusqu'à partie historique css dans gros fichier de 5000 lignes. <br />
                            Peu d'orga, rangement par couche (1 couche === 1 fonctionnalité). Difficile de voir dans la css ce qui était vraiment utilisé et dans quelle partie de partie dl'application. <br />
                            Au fil des évos du site, code non utilisé, chargé et alourdi les données téléchargées. <br />
                            Et c'est comme ça qu'on se retrouve avec 15% de css qui porte sur du code mort  <br />
                            profité d'une migration de la css existante vers sass pour ne porter que le code qui était réellement utilisé sur le site. <br />
                            fichiers séparés par type d'affichage ==> devrait à l'avenir limiter ce risque de cumul de code mort. <br />
                            Néanmoins, sur le long terme, avoir un outil automatisé de détection du code css mort et une intégration continue sur ce point parait indispensable.
                        </aside>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Réduire les contenus bloquants</h1>

                        <aside class="notes">
                            Moins de ressources chargées, contenu plus léger, maintenant comment continuer à accélérer notre site. <br />

                            Nous nous sommes penchés sur les contenus bloquants. <br />

                            fait en sorte de livrer dès le début la feuille de style afin d'avoir le plus vite le rendu définitif. <br />

                            Mais avant qu'une page ne puisse s'afficher, elle doit être analysée par le navigateur. <br />

                            Et si le navigateur tombe sur un contenu bloquant, s'arrêter, le télécharger et le traiter ==>  retarder l'affichage. <br />

                            Il faut donc identifier sur pages tous les types de contenus qui pourrait être bloquants <br />
                            puis reporter leur exécution et chargement après le chargement de la page.

                        </aside>
                    </section>

                    <section>
                        <h2>Rendre l'exécution du javascript non bloquante</h2>

                        <ul>
                            <li>Descendre les fichiers</li>
                            <li>Charger en async</li>
                        </ul>


                        <aside class="notes">
                            Parmi ces contenus bloquants on trouve fichiers javascripts. <br />

                            Traiter le js dès le début n'est pas utile. <br />
                            Quand le navigateur rencontre une balise script ==> la traiter directement. <br />
                            Et si les script n'est pas inline, il va devoir charger la ressource. <br />
                            pas nécessaire pour le rendu que les interactions ajoutées par javascript soit chargées immédiatement. <br />
                            nettoyé une partie de nos pages pour décaler les appels de fichiers javascripts du head vers le bas de la page.  <br />

                            Attention refactoring pour gérer js inline si vous en avez <br />
                            les scripts qui comptaient sur la présence d’un js chargé immédiatement ne fonctionneront plus et lèveront une erreur. <br />

                            pouvez aussi utiliser l'attribut async pour charger vos fichier javascript. <br />
                            téléchargement et traitement du fichier javascript seront fait en parallèle.  <br />
                            Votre fichier plus bloquant pour rendu de la page, mais rendra indéterminable moment où fichier sera exécuté. <br/>
                            A vous de voir quelle situation vous convient le mieux.  <br />

                            Malheureusement, je n'ai pas de comparatif à vous montrer pour cette optimisation.  <br />
                            Nous avons fait cette modification début 2015 en même temps qu'une refonte totale de la page produit, ce qui fait qu'il est impossible de quantifier l'impact spécifique de cette modification parmi toutes les autres modifications effectuées.
                        </aside>
                    </section>



                    <section>
                        <h2>Auditer les scripts externes</h2>

                        <img src="images/requestmap.png">

                        <aside class="notes">
                            Tracking, retargeting, widget de réseaux sociaux, à un moment donné, finit par charger sur site scripts qu'on n'héberge pas ou sur lesquels pas la main. <br />
                            Et bien sûr un jour arrive ces scripts tombent, et s'ils sont chargés synchrone, attendre  timeout navigateur pour reste page finisse par  charger. <br />
                            Pour évitez ça, auditez, regardez ce qui est chargé, quand et de quelle manière.  <br />

                            Voici graphique représentant dépendances de notre FP effectué sur webperftools.  <br />

                            Voit très bien que moitié des dépendances, partie  droite, à cause d'un seul script. <br />
                            Faire attention à ce que ce script, ne fasse pas tomber notre page. pouvez tester cela dans webpagetest indiquant dans configuration SPOF domaines  vous souhaitez ne pas pouvoir charger. <br />
                        </aside>
                    </section>


                    <section>
                        <h2>Auditer les scripts externes</h2>

                        <ul>
                            <li>Auditez les scripts</li>
                            <li>Améliorez leur qualité</li>
                        </ul>

                        <aside class="notes">
                            avons également mis l'accent sur qualité ressources externes. Tout ce que je vous ai dit plus tôt sur compression des contenus, le cache, etc. n'est parfois pas mis en place sur ces scripts partenaires. <br />

                            regardez bien  ce que vous avez sur vos sites, lisez bien les documents d'intégration de ces scripts (qualité technique du module) <br />
                            Et n'hésitez pas à leur remonter ces problèmes pour qu'ils fassent le nécessaire : ça sera bénéfique pour eux et surtout pour vous.  <br />

                            Pour terminer, ces scripts sont là souvent pour des raisons de business et il faut être conscient qu'ils ont quand même un coût technique. <br />

                            Pour comparer entre decitre.fr et une de nos MB qui est mm plateforme, mais avec nettement moins de ces scripts externe ==>  delta de près d'1s sur le temps de chargement global entre les deux sites.
                        </aside>
                    </section>




                    <section>
                        <h2>Paralléliser les chargements des images</h2>

                        <ul>
                            <li>Augmenter la capacité à paralléliser</li>
                            <li>Attention aux coûts du sharding</li>
                        </ul>
                        <aside class="notes">
                            Homepage (création édito, visuels produits, images dans la CSS) + 50 images utilisées sur la page. <br/>
                            FP quarantaine. Les images sont le type de ressource le + appelé <br/>
                            HTTP 1, navigateur peut paralléliser les appels, mais limite de 6 connexions/domaine. Comment détourner limite et améliorer le tmps de chargement ?  <br />
                            Technique pour augmenter la capacité à paralléliser en chargeant sur de nouveaux domaines : domain-sharding <br />
                            www.decitre.fr/mon-image.jpg ==> media.decitre.fr/mon-image.jpg (image : media, reste www)

                            Attention : nouveau domaine == 1 résolution DNS à faire + nouvelle connexion potentiellement très coûteuse. <br />
                            Peut ne pas être rentable. Bien évaluer le nombre de domaine sur lequel on compte effectuer la répartition. <br />

                            Exemple de test sans impact final. On voit l'effet dans webpagetest, la parallélisation fonctionne. toutefois pas d'impact dans GA il n’y a pas eu gain notable suite à cette mise en place.
                        </aside>
                    </section>

                    <section>
                        <h2>Charger différement les iframe</h2>

                        <ul>
                            <li>Charger en non bloquant</li>
                        </ul>


                        <aside class="notes">
                            Scripts externes, vidéos, il arrive parfois qu'on ait à sortir de notre à outil à la balise iframe. <br />
                            Et niveau contenu bloquant, c'est pas ce qu'il y a de mieux. <br />

                            Pour ça, nous nous sommes créés mécanisme de chargement d'iframe asynchrone, activé une fois que  le contenu principal est chargé.

                            Cela nous permet de créer l'iframe à ce moment là avec les paramètres que nous souhaitons.
                            Avons pu décaler les chargements contenus moins prioritaires à plus tard et enlever source de blocage de nos pages.

                        </aside>
                    </section>


                </section>

                <section>
                    <section>
                        <h1>Et ensuite ?</h1>
                        <aside class="notes">
                            Voilà pour les modifications que nous avons effectuées.
                            Quels sont les axes d’améliorations que nous avons prévu pour la suite.
                        </aside>
                    </section>

                    <section>
                        <h2>HTTP/2</h2>
                        <aside class="notes">
                            Gros chantiers vers lequel on va se pencher dans les prochains mois sera de basculer vers HTTP/2. <br />

                            Pourquoi cette bascule est intéressante ? <br />

                            Parmi les avancées de HTTP/2 on peut citer : <br />
                            Le multiplexage des requêtes : le navigateur n’ouvre plus qu’une seule connexion par domaine, mais il peut désormais envoyer et recevoir plusieurs messages en parallèles. <br />
                            La compression des headers est désormais possible que ce soit pour les réponses ou les requêtes. Cela permet de réduire la bande passante utilisée.<br />
                            Le cache pushing qui permet dans une réponse d'envoyer du contenu lié. Par exemple, lorsque je demande ma page HTML, je peux directement lier la feuille de style. <br />

                            Au final, parmi les points dont je vous ai parlé plus tôt, si on prends le domain sharding ou le keepAlive, voire la concaténation des assets ceux-ci sont rendus inutiles par une implémentation de HTTP/2. <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Autres pistes</h2>

                        <p>Travailler sur le chemin critique du rendu navigateur</p>

                        <aside class="notes">
                            En piste d'amélération, nous pourrions également nous pencher sur les optimisations côté navigateur pour que la page s'affiche au plus tôt les contenus nécessaires à l'utilisateur. <br />

                            Notamment, en optimisant le chemin critique du rendu navigateur, nous pourrions arriver à ça. <br/>

                            Dejà en nettoyant et continuant de simplifier le code HTML et CSS, puis en travaillant par exemple sur l'extraction de la partie critique de la CSS et en l'injectant dans le code HTML<br />


                            Mais c’est un autre pan de l’optimisation de la performance sur lequel nous n’avons pas travaillé et que je ne développerai pas. <br/>
                        </aside>
                    </section>

                    <section>
                        <h2>Pour aller plus loin</h2>

                        lien en vrac : page speed - yslow
                        doc google + edasf + autre
                        compte twitter

                    </section>
                </section>

                <section>
                    <h2>Impliquez vos équipes</h2>

                    <ul>
                        <li>Intégrez la web performance dans votre culture d'équipe</li>
                        <li>Créez vos process</li>
                        <li>Mesurez</li>
                        <li>Vendez votre travail</li>
                    </ul>


                    <aside class="notes">
                        Comme la revue de code, le testing ou pleins d'autres bonnes pratiques, la performance web doit rentrer dans votre culture d'équipe. <br />

                        Mettez des process pour les impacts des modifications, par exemple en pensant à tester vos pages dans un webpagetest après un développement. <br />

                        On ne peut améliorer ce qu’on ne mesure pas <br />
                        Ajoutez dans votre intégration continue des mesures régulières pour en suivre l'évolution. Par exemple avec le projet Phantomas qui permet de collecter tout un ensemble de mesures. <br />

                        Chez nous, on utilise gtmetrix. C'est un outil SAAS qui permet de tester plusieurs fois par jours certaines de nos pages critiques. <br />
                        Et on reçoit ensuite toutes les semaines l'évolution des métriques sur ces pages. <br />

                        Enfin, certes en tant qu'équipe de développement, nous avons un impact fort sur le site. Mais nous ne sommes pas les seuls à influer sur le contenu du site. <br />
                        Nous avons aussi chez nous des équipes éditoriales qui interviennent tous les jours sur le site. <br />

                        Donc expliquez-leur et vendez-leur votre culture de la webperf pour qu'ils se l'approprient. <br />
                        Exposez vos métriques et accompagnez les dans l'application de vos process, de manière à ce que tout ceux qui travaillent sur vos sites aient conscience de ces enjeux.
                    </aside>
                </section>

                <section>
                    <h2>Tout ça pour quels résultats</h2>

                    <img src="images/graph_final_petit.png">

                    <aside class="notes">
                        Durant les deux dernières années, on a de manière itérative, effectué toutes ces modifications, dans l'objectif de charger le minimum, au plus vite en décalant le superflu à plus tard. <br />

                        Plein d’optimisation, mais contrairement aux exemples célèbres cités en intro, il n'y pas eu d’effet sur le business ou sur le SEO. <br />

                        A voir sur le plus long terme, car beaucoup de grosses modifications ont été faites au cours de la dernière année. <br />

                        Mais même si d'un point de vue business, les effets sont mitigées, d'un point de vue de la perception utilisateur, ça reste bénéfique d'avoir un site et des pages qui répondent plus vite. <br />

                        Dans tous les cas, pour moi l'objectif de ce sujet c'était de vous présenter ces aspects. <br />
                        De montrer que même dans une petite équipe on peut travailler sur ces éléments qui pour la plupart sont assez faciles à mettre en oeuvre. <br />
                        Et aussi de vous rappeler qu'il n'y a pas le back dans la vie mais également plein de travail super intéressant à faire de l'autre côté du serveur.
                    </aside>
                </section>

                <section>
                    <h1>Merci pour votre attention</h1>

                    <h3>Des questions ?</h3>
                </section>

            </div>




        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                slideNumber: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>
