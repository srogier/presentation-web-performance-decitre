<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>De 7 à 3s : retour d’expérience sur la performance Web sur decitre.fr - PHP Tour Clermont‑Ferrand - 24 mai 2016</title>

        <meta name="description" content="De 7 à 3s : retour d’expérience sur la performance Web sur decitre.fr - PHP Tour Clermont‑Ferrand - 24 mai 2016">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/srogier.css" id="theme">
        <link rel="stylesheet" href="css/font-awesome.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <div class="slides">
                <section>
                    <h1>De 7 à 3s : retour d’expérience sur la performance Web sur decitre.fr</h1>
                    <h3>PHP Tour Clermont‑Ferrand - 24 mai 2016</h3>
                    <a href="https://twitter.com/srogier"><i class="fa fa-twitter"></i>@srogier</a> /
                    <a href="https://github.com/srogier"><i class="fa fa-github"></i> srogier</a>

                    <aside class="notes">
                        Je vais vous présenter aujourd'hui le travail effectué sur la performance Web sur notre site. <br />

                        Lors des deux dernières années sur decitre.fr, nous avons fait la chasse à la seconde côté front (en réduisant et allègeant les ressources exposées) et côté back (notamment avec une migration vers PHP7) afin d’en améliorer l’expérience utilisateur. <br />

                        Je vous parlerai de pourquoi la web performance est important, quelles optimisations ont été faites et les résultats constatés. <br />

                        Nous sommes à un évènement de l’AFUP,  et je suppose que la plupart d’entre vous sont des développeurs PHP. Vous avez l’habitude du backend, de suivre les performances coté PHP.<br />

                        Mais je voulais parler de tout l’aspect performance hors serveur qui pouvait être parfois méconnu de beaucoup d’entre nous. <br />

                        Je ne vous parlerai donc très peu d’optimisations serveur, mais je présenterai tout ce qu’on a pu faire pour accélérer l’affichage de nos pages sur decitre.fr <br />

                    </aside>
                </section>

                <section>
                    <h1>Decitre.fr</h1>
                    <section>
                        <h2>L'équipe</h2>

                        <ul>
                            <li>3 développeurs + 1 CTO</li>
                            <li>une dizaine de personnes hors technique</li>
                        </ul>

                        <aside class="notes">
                            Je suis développeur chez Decitre Interactive, au sein d’une équipe technique composée de 4 personnes (3 dev et un directeur technique). <br />

                            Nous éditons decitre.fr, une librairie en ligne, qui est basée sur magento. <br />

                            Nous gérons également des versions en marque blanche de notre site, une version B2B, et proposons un outil en mode SAAS de recherche bibliographique basé sur du symfony 2. <br />

                            Voilà pour le contexte de l'équipe technique. <br />

                            Autour de nous, on a dizaine de personnes qui interviennent sur le site pour en gérer son contenu, les clients ou bien le SEO.<br />
                        </aside>
                    </section>

                    <section>
                        <h2>Le site</h2>

                        <ul>
                            <li>4,2 millions de pages vues par mois</li>
                            <li>1.2 million de produits</li>
                        </ul>

                        <aside class="notes">
                            Decitre.fr existe depuis 1997. La version actuelle basée sur magento a été mise en ligne en 2012.<br />

                            Pour vous donner une idée du trafic du site, c’est 4,2 millions de pages vues par mois.<br />
                            Quant à notre catalogue produit, on comptabilise 1.2 million de livres et ebooks.<br />

                        </aside>
                    </section>
                </section>




                <section>

                    <section>
                        <h1>Qu'est-ce que la web perfomance ?</h1>

                        <aside class="notes">
                            La performance web c'est tout simplement comment afficher au plus vite son site Internet. <br />
                            Historiquement, on va remonter en 2007 et l'apparition des yahoo rules for web performance rédigées par Steve Souders. <br />
                            Ce sont 14 bonnes pratiques proposées par ordre d'importance <br />
                            applicables pour tous les sites qui permettent d'améliorer la rapidité d'affichage de son site.<br />
                            Toutes ces pratiques étaient connues avant <br />
                            mais cela a été un des premières compilation de tout cet ensemble de règles.<br />

                        </aside>
                    </section>

                    <section>
                        <h2>L'importance de la performance web</h2>

                        <aside class="notes">
                            Pourquoi la PW est importante ? pourquoi cherche-t-on à afficher le plus vite possible les pages à nos utilisateurs ? <br />
                            Exemple connus monde du web corréler perf technique et perf business <br />
                            Walmart : 1s de chargement => augmentation du taux de conversion de 2 %; <br />
                            Google : tps chargement + 500ms => baisse de 20% du traffic.
                            tps de chargement , Influence sur le nombre de page vues, sur le taux de rebond, sur la conversion <br />
                            Critère SEO : google admet vitesse pris en compte dans leur algo de recherche <br />
                        </aside>
                    </section>


                    <section>
                        <h2>Qu’est-ce que le Web ?</h2>

                        // TODO image OSI

                        <aside class="notes">
                            On va ressortir des cartons le modèle OSI.  <br />
                            Le web, s'appuie le protocole TCP/IP. <br />
                            C'est à dire, une communication via un réseau physique interfacé avec une couche IP pour l'adressage <br/>
                            TCP qui se charge du transport des données <br />
                            et en haut couche application  retrouve serveur HTTP.
                        </aside>
                    </section>


                    <section>
                        <h2>Qu’est-ce que le Web ?</h2>

                        // TODO image network

                        <aside class="notes">
                            Le web, C un système client serveur. <br />
                            navigateur via réseau communique avec serveur backend. <br />
                            Quand on affiche une page, 15 à 20% du temps avant l'affichage complet se passe sur le serveur. <br />
                            80 et 85% du temps consacré au reste ==> cad traitement de la page par le navigateur et le transfert réseau. <br />
                            Avec de telles répartitions, on voit assez bien que pour accélérer sa page, la marge de manoeuvre n'est pas sur le serveur. <br />
                        </aside>
                    </section>

                </section>


                <section>
                    <section>
                        <h1>Optimiser le serveur</h1>

                        <aside class="notes">
                            La partie serveur va donc être assez courte.
 <br />
                            Quand même vous parler des outils utilisé pour suivre les performances code PHP + grosses optimisations faites. <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Mesurer les performances</h2>

                        <ul>
                            <li>New relic</li>
                            <li>Blackfire</li>
                        </ul>
                        <aside class="notes">
                            Pour commencer, parler des principaux outils que nous utilisons pour suivre développements PHP.<br />
                            New Relic suivre tout ce qui se passe sur nos serveurs. <br />
                            outil de monitoring applicatif le plus utilisé. <br />
                            Retrouvons dedans toutes les erreurs applicatives, les temps de réponse, requêtes et pages lentes, évolution du trafic, le tout historisé. <br />
                            Très bon outil pour suivre évolution mode macro sur quelques mois  <br />
                            mais aussi avoir aperçu ce qui se passe pendant laps de temps très court lorsqu rencontre des pics de charge. <br />
                            Pour rentrer plus dans le détail et suivre nos optimisations de code PHP, nous utilisons Blackfire. <br />
                            Je pense que vous connaissez tous, outil qui permet profiler dans le détail le temps, la mémoire consommée par nos scripts php pour identifier les appels les plus consommateurs. <br />
                            C'est un outil qu'on utilise surtout phase de dév lorsque effectuons nos modifications, pour s'assurer pas de régression de performance.<br />
                        </aside>
                    </section>

                    <section>
                        <h2>Migrer vers PHP 7</h2>

                        <ul>
                            <li>New relic</li>
                            <li>Blackfire</li>
                        </ul>
                        <aside class="notes">
                            Le sujet du moment dans le monde PHP : PHP 7 et gains de perf promis avec cette nouvelle version. <br />

                            Pour ceux que ça intéresse, Julien Pauli présentera comparatif des performances de PHP 5 vs PHP 7 au PHPTour à Clermont Ferrand. <br />

                            Pour ceux qui étaient ici aux lightning d'il y a mois, tenté de vous vendre la migration à PHP7. <br />
                            Malheureusement, chez nous elle n'est pas encore effectuée.<br/>

                            Nous sommes en train de préparer des serveurs, c’est donc un question de jours/semaines avant que la migration soit faite. <br/>
                            Sauf suprise j’aurais des chiffres pour le PHPTour.<br/>

                            Sur preprod, constat que pages étaient + rapide de l'ordre de 20 à 40%. <br/>
                            Les chiffres valent ce qu'ils valent : env avec peu de trafic, donc attention.<br/>
                            Mais globalement on est dans les valeurs attendues. Donc attendons la mise en prod.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>L'importance du réseau</h1>

                        // TODO image bande passante

                        <aside class="notes">

                            Pour que navigateur et serveur communiquent , passage réseau (partie basse vue dans modèle OSI de tout à l’heureà. <br />
                            Souvent quand on pense réseau, on va penser bande passante. <br />
                            Bande passante : capacité à transmettre des données pendant un temps. <br />
                            On peut penser que + elle sera élevée, plus notre page va se télécharger rapidement, <br />
                            Mais comme on peut le voir sur le graphique, l'amélioration ne dure qu'un temps : la bande passante n'est plus le goulot d'étranglement.<br />
                        </aside>
                    </section>


                    <section>
                        <h2>L'importance du réseau</h2>

                        // TODO image bande latence

                        <aside class="notes">
                            Prise en compte un second critère : la latence. <br />
                            Délai nécessaire pour que les paquets fasse A/R entre le navigateur et le serveur. <br />
                            Temps qui va principalement dépendre du réseau sur lequel vous vous trouvez (mobile, connexion 3G entre 100 et 500ms, fixe  général inférieure à 20 ms)<br />
                            La distance physique entre le navigateur et le serveur influe également. <br />
                            Prend en compte le temps qu'il faut au signal pour passer de l'un à l'autre : + on est loin, plus la latence va être importante. <br/>
                            raison pour lesquelles utiliser un CDN est avantageux. Votre contenu est dupliqué sur des serveurs répartis tout autour du monde. Contenu servi par le serveur le + proche pour limiter l'impact de la latence. <br />

                           tester très facilement impact latence dans outils de développement de votre navigateur. Réglage seuils de bande passante et de latence pour en visualiser l'impact. <br />
                           Sur mac, paramétrer dans options de connexion. <br />
                           Donc pour minimiser l'impact de la latence, on a deux possibilités : soit on rapproche navigateur et serveur pour en réduire la valeur, soit on réduit le nombre de requête serveur pour en réduire la quantité. <br />

                        </aside>
                    </section>


                    <section>
                        <h2>Anatomie d’un hit HTTP</h2>

                        // TODO image waterfall

                        <aside class="notes">
                            Quand on consulte une page, navigateur récupère la page HTML et les fichiers associées. <br />
                            Visible onglet network navigateurs. <br />
                            Obtient liste des tous les éléments chargés, la page, les feuilles de styles, les scripts, les images, etc. dont notre page a besoin, le moment où ils sont chargés, combien de temps ce chargement a mis. <br />

                            On va rentrer dans le détail d'un des hits HTTP pour voir plus précisément ce qui se passe.

                        </aside>
                    </section>


                    <section>
                        <h2>Anatomie d’un hit HTTP</h2>

                        <img src="images/timing_hit_http.png" class="fragment">

                        <aside class="notes">
                            1. 3 1ere lignes Temps d'attente avant envoi (restriction navigateur) <br />
                            2. Requete DNS. indentification du serveur si on connu<br />
                            3. Etablissement de la connexion. Retombe sur les parties basses du modèle OSI de tout à l'heure<br />
                            3.bis au besoin négo TLS, cf ligne SSL<br />
                            4. connexion établie : envoi de la requete
                            5. le serveur (traite, prépare contenu). attente du premier paquet reçu par le nav : TTFB<br />
                            5. Téléchargement <br />

                            Pour visualiser ces informations, vous pouvez également utiliser webpagetest.org. <br />
                            URL + lieu physique test joués + nav + eventuellement réseau (BP + latence). <br />
                            Attente qq sec le tps que le test s'éxécute (2 waterfall 1er hit et impact cache)<br />
                            Installable sur infra pour tests urls dev + privées <br />

                            Sur cet exemple, entre la recherche DNS, l'établissement de la connexion, l'envoi de la requête et son téléchargement, on va évidemment faire appel au réseau.
                            à chaque A/R serveur nous serons confrontés aux problèmes de latence. <br />

                        </aside>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Faire moins de requêtes</h1>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>Supprimer les images inutiles</h2>

                        // code bouton moche + images

                        <aside class="notes">

                            Donc l'objectif, c'est de charger moins de ressources. Pour commencer autant s'attaquer à toutes les images chargées inutilement dans notre CSS.<br />
                            Environ 20 images sur la home chargées dans la CSS. <br />
                            Mise en forme du footer, barre de recherche, mini panier.<br />
                            Présentation des modifications effectuées pour réduire ces appels.  <br />

                            Parenthèse historique : souhait de compat et de rendu similaire IE7 -> chrome dernière version. de google chrome. L’intention était louable, mais en pratique cela peut tourner au drame. <br />

                            Voici le code d'un bouton. catastrophe : structure HTML complexe, tas énorme de CSS et une image à charger pour les coins arrondis. <br />

                            Et ce sur tous les types de boutons que notre site pouvait utiliser. Je vous laisse imaginer tous les problèmes de maintenance liés. <br />

                            Refonte avec de la CSS 3 : gradient et border-radius. <br />
                            suppression désagréable effet de clignotement visible au premier chargement et surtout plus d'images à télécharger <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Utiliser des sprites</h2>

                        <ul>
                            <li>Concaténation d'images en une seule</li>
                            <li>1 seul hit HTTP</li>
                        </ul>


                        <aside class="notes">

                            Point positif à retirer de nos anciens boutons, c’est qu’ils utilisaient une sprite. <br />
                            Pour définir ce qu'est une sprite : technique consiste assembler plusieurs images en une seule<br />
                            équivalent de la concaténation de fichier pour les images <br />
                            L’avantage un seul appel réseau pour charger plusieurs éléments regroupés. <br />
                            On applique l'image sur elt HTML via CSS : sprite en background image + position pour afficher l'élément souhaité <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Utiliser des font d'icônes</h2>

                        <img src="https://github.com/Decitre-Interactive/b2c/blob/82461bdc6f6574062c01eaf4367d8cc34ead9117/magento/www/skin/frontend/decitre/default/images/titre_picto_ul_bottom.png">

                        <ul>
                            <li>1 fichier (100 icônes) VS plusieurs sprites</li>
                            <li>Poids faible : 16 Ko</li>
                        </ul>

                        <aside class="notes">
                            Par contre, il y a certains éléments pour lesquels les sprites existantes ne nous intéressaient pas.<br />
                            Prenons l'exemple de cette image  <br />
                            Bonne nouvelle, on n'a pas 4 images mais une seule <br/>.
                            Par contre, pictogrammes tout simple (loupe, panier, logo, etc.) fond bleu dégradé faisable CSS. <br />

                            Pour ces images là : choix d'utiliser des font-icônes. <br />
                            Un fichier svg par icone, tache qui compiles cvgs en font utilisables sur le site. <br />

                            Remplacement de plusieurs sprites, ici chargement d'un seul fichier font permet avoir centaines icones chargées. <br />
                            Le tout pour une taille raisonnable (fichier font 16 Ko poour comparer l'image de 4 icônes 2 Ko) <br />

                            Au final sur decitre.fr, on utilise peu de sprites. La quasi totalité de nos pictogrammes sont disponibles dans la font d'icônes.

                        </aside>

                    </section>


                    <section>
                        <h2>Utiliser les Data URI</h2>

                        <img src="https://github.com/Decitre-Interactive/b2c/blob/ticket_8428_upgrade_solr/magento/www/skin/frontend/decitre/default/images/reduc_bg.png">

                        // TODO faire un code avant/après



                        <aside class="notes">
                            Enfin, nous avions des petites images que nous utilisions fréquement, <br />
                            plutôt que faire un hit HTTP, nous les avons directement intégré dans la CSS ou le code HTML.   <br />

                            Comment vous pouvez le voir, au lieu de mettre l'URL de l'image, nous avons mis sa data-URI.   <br />
                            On économise ainsi un hit HTTP.

                        </aside>
                    </section>

                    <section>
                        <h2>Exemple concret avec le footer</h2>


                        // image avant après

                        // webpagetest avant après

                        <aside class="notes">

                            exemple le plus visuellement parlant du travail sur images est ce que nous avons fait sur notre footer. <br />
                            Voici le pied de page tel qu'il était affiché il y a encore quelques mois. <br />
                            En rouge images spécifiquement utilisées pour ce bloc. <br />
                            en tout plus de 10 images utilisées pour ce footer.<br />
                            Voici ce que nous avons fait pour le remplacer en utilisant les différentes techniques dont je viens de parler. <br />
                            On a refait un peu le design et toujours en rouge, on retrouve les différentes images sur la nouvelle. <br />

                            Pour finir le comparatif, deux webpage tests avant et après changement. <br />
                            Non seulement, nettoyage permis d'avoir à un moindre coût un footer plus moderne, <br />
                            mais aussi avons pu faire économie d'un certain nombre d'appel serveurs et accélerer l'affichage de nos pages.<br />

                        </aside>
                    </section>


                    <section>
                        <h2>Gérer le cache</h2>

                        <ul>
                            <li>Cache HTTP</li>
                            <li>Durée de cache</li>
                        </ul>

                        <aside class="notes">
                            Lorsqu'il télécharge fichier, navigateur a possibilité de mettre de côté pour le réutiliser un peu plus tard s'il est utilisé ailleurs. <br />
                            C'est ce qu'on appelle le cache HTTP. <br />
                            Permet de limiter les allers retours entre le serveur et le navigateur en stockant côté utilisateur des ressources réutilisables.  <br />
                            Chez nous, On défini le mécanisme de cache via l'entête HTTP Cache-Control. <br />

                            En fonction du type de page (recherche, FP, cat), règle ensuite durée de validité avec une valeur allant de qq minutes à une heure. <br />
                            Pour les images, durée de mise en cache + importante et monte à qq heures.  <br />
                            Quant aux assets js/css, là on utilise une valeur de cache beaucoup plus importante.  <br />
                            Pour ces fichiers, les urls uniques et évoluent en fonction contenu ==>  durée de cache peut être en théorie illimitée.
                        </aside>
                    </section>


                    <section>
                        <h2>Garder les connexions ouvertes</h2>

                        // TODO montrer capture requete en parallèle

                        KeepAlive

                        <aside class="notes">
                            On a vu tout à l'heure qu'à chaque fois que le navigateur récupèrait un fichier, il établissait une connexion. <br />

                            Côté serveur, peut spécifier directive qui s'appele Keep-Alive ==> permettre de garder ouverte connexion pendant un temps donné. <br />

                            Ainsi, navigateur lorsqu'il va demander une ressource sur domaine où la connexion déjà ouverte, pourra la réutiliser <br />
                            au lieu d'en ouvrir une autre, ce qui nous économisera des allers/retours réseaux d'intialisation de connexion. <br />

                            Paramètre qui se règle sur votre serveur web et sur lequel vous réglez la durée d'ouverture de la connexion. <br />

                            juste faire attention à ne pas affecter une valeur trop importante sur le KA <br />
                            risque d'avoir effet inverse et saturer les serveurs en gardant trop longtemps les connexions ouvertes. <br />

                            pouvez analyser les temps nécessaires à la récupération de vos fichiers pour estimer quelle valeur appliquer sur vos sites.
                        </aside>
                    </section>

                    <section>
                        <h2>Concaténer les assets</h2>

                        <aside class="notes">
                            Bcp de fichier js et CSS <br />
                            chez nous, 10 css et 70 js  <br />
                            Comme on l'a vu tout à l'heure charger ces fichiers un par un serait catastrophique pour les performances réseaux. <br />
                            On va donc concaténer ensemble tous fichiers javascripts et tous fichiers CSS <br/>
                            éviter les AR inutiles entre le client et le serveur. <br />
                            Pour beaucoup ici, pratique triviale et évidente. <br />
                            Mais dans un écosystème tel que magento, une option configurable dans le back office. <br />
                            signifie que sites peuvent partir en prod sans se soucier d'avoir allégé le nombre de ressources appelées. <br />
                        </aside>
                    </section>


                    <section>
                        <h2>Lazy-loader les images</h2>



                        <aside class="notes">
                            On a supprimé les images inutiles plus tôt, mais il en reste encore beaucoup. <br />

                            Charge donc plein d'images qui pour certaines d'entre elles sont trop bas dans la page et ne seront jamais affichées.<br />
                            C'est dommage, c'est du chargement inutile. <br />

                            Pour résoudre problématique mis en place mécanisme sur visuels : le lazy loading. <br />

                            Pour ceux qui ne connaissent pas, technique qui consiste à décaler chargement d’une ressource au moment où on en a vraiment besoin. <br />
                            Pour visuels, revient à ne charger les images qu’à partir du moment où elles sont dans le viewport, CAD dans zone visible par l'utilisateur. <br />

                            temps de chargement initial de la page réduit et images ne sont chargées que si elles sont affichées par l’utilisateur.

                        </aside>
                    </section>


                    <section>
                        <h2>Lazy-loader les images</h2>


                        <aside class="notes">

                            Voici comparatif webpagetest avant / après ajout du lazyloading. <br />

                            Comme vous pouvez le contaster on a réduit le nombre de ressources chargées.  <br />

                            Dans le cas des images de notre FP, permis d'économiser une vingtaine d'A/R avec le serveur. <br />

                            En terme de temps de réponse, indicateurs de temps de chargement utilisateurs remontés dans GA indique passage de 4.80s à 4.10s, <br />
                            ce qui est une de plus grosses optimisations effectuées sur le site. <br />
                        </aside>
                    </section>





                </section>

                <section>
                    <section>
                        <h1>Alléger les ressources</h1>

                        <aside class="notes">
                            Je viens de vous présenter ce que nous avons fait pour charger moins de ressources sur notre site et réduire les allers retours avec le serveur.

                            Maintenant, je vais vous parler de ce que nous avons fait pour alléger les requêtes restantes.
                        </aside>
                    </section>


                    <section>
                        <h2>Compresser le contenu</h2>

                        <ul>
                            <li>Activer la compression gzip</li>
                            <li>Diminution de la bande passante</li>
                            <li>Facteur 5 de compression</li>
                        </ul>


                        <aside class="notes">
                            Une des modifications qu’on a fait dès le début pour alléger les ressources a concerné la compression des ressources livrées. <br />
                            Allégèment des fichiers retournés par le serveur. Activation compression gzip. Effet visible dans GA. <br />
                            Non seulement, ressources moins lourdes à charger<br />
                            Quota de bande passante : des données moins lourdes qui transitent. <br />
                            Pertinent pour les fichiers de type texte. Image déjà optimisée <br />
                            Page d'accueil (html + css + js) 1 Mo après gzip 200Ko. <br />
                        </aside>
                    </section>


                    <section>
                        <h2>Minifier les assets</h2>

                        <ul>
                            <li>Suppression des caractères inutiles, simplification du code</li>
                            <li>Pas en place chez nous</li>
                        </ul>

                        // TODO chiffrer gain potentiel

                        <aside class="notes">
                            Après la concat des CSS et JS, bonne pratique suivante : minification <br />
                            Suppression des caractères inutiles (espaces, tab), commentaires, simplification des noms de variables pour le JS.  <br />
                            Permet d'avoir des versions allégées en prod <br />
                            Pas mis en place chez nous. Cout de mise de place de la couche supplémentaire pas assez rentable par rapport aux autres modifications possibles pour le même temps. <br />
                            Pour la partie css, nous avions tenté de le faire, mais à cause de nos contraintes de déploiement, nous avons abandonné cette solution, quitte à alourdir un peu nos ressources.<br />
                        </aside>
                    </section>

                    <section>
                        <h2>Utiliser des domaines cookieless</h2>



                        <aside class="notes">
                            points précédents, j'ai parlé de réduire temps livraison fichiers statiques via différents mécanismes compression. <br />
                            Egalement travail sur  l'optimisation des requêtes serveur pour les ressources statiques. <br />
                            On a tous des cookies sur nos sites Internet.<br />
                            Chaque hit sur le domaine du cookie ==> envoi du cokie. ==> coût car il faut uploader le cookie. <br />
                            Dans le cas de fichiers statiques comme les images ou les feuilles de style, quel intérêt a-t-on à transmettre les cookies utilisateurs ? Aucun. <br />
                            Autre domaine di-static pour servir ces ressources. Cookies liées à decitre.fr donc non envoyé. <br />
                            Requete allégée. Appréciable mobile upload faible. <br />

                        </aside>
                    </section>

                    <section>
                        <h2>Optimiser les images</h2>



                        <aside class="notes">
                            J'ai beaucoup parlé d'image un peu plus tôt et du travail qui avait été fait pour en réduire le nombre. <br />
                            Autre problème concernant le poids. <br />
                            Un jour, se retrouve avec images qui font un 1/2 Mo sur page d'accueil <br />
                            Qu'avons nous fait pour empêcher cela ? <br />
                            Sensibiliser différentes équipes qui interviennent sur le site <br />
                            Si on n'explique pas risques liés au poids des images et ce que cela implique pour nos clients ==> on ne peut s'en prendre qu'à nous mêmes <br />
                            PNG et jpeg sont des formats où les images sont compressées, mais souvent pas de manière optimale pour le web.  <br />
                            Présentation d'un outil en ligne pour compresser les images comme tinypng. Chiffre à l'appui pour montrer l'importance et la nécessité de l'étape.<br />
                            Nettoyage côté dev sur les images du dépot sur lesquelles nous ne nous étions jamais penchés. <br />
                            Nettoyage permis diviser taille de toutes les images stockées, passage de 4Mo à 2 Mo.  <br />
                        </aside>
                    </section>

                    <section>
                        <h2>Nettoyer le code mort</h2>
                        <aside class="notes">

                            Jusqu'à partie historique css dans gros fichier de 5000 lignes. <br />
                            Peu d'orga, rangement par couche (1 couche === 1 fonctionnalité). Difficile de voir dans la css ce qui était vraiment utilisé et dans quelle partie de partie dl'application. <br />
                            Au fil des évos du site, code non utilisé, chargé et alourdi les données téléchargées. <br />
                            Globalement, nous préférons migrer de manière itératives lorsque nous refactorons des éléments (comme notre fiche produit ou des widgets) nous conservons les anciennes versions.
                            Cela permet de mettre en place du test AB avant de les supprimer. <br />
                            Mais cela nous permet aussi de limiter et étaler le coût de leur migration en portant au fur et à mesurer.<br />
                            Inconvénient : code mort. 15% de css qui porte sur du code mort  <br />
                            On a profité d'une migration de la css existante vers sass pour ne porter que le code qui était réellement utilisé sur le site. <br />
                            On a ainsi des fichiers séparés par type d'affichage, ce qui devrait à l'avenir limiter ce risque de cumul de code mort. <br />
                            Néanmoins, sur le long terme, avoir un outil automatisé de détection du code css mort et une intégration continue sur ce point parait indispensable.
                        </aside>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Réduire les contenus bloquants</h1>

                        <aside class="notes">
                            Moins de ressources chargées, contenu plus léger, maintenant comment continuer à accélérer notre site. <br />

                            Nous nous sommes penchés sur les contenus bloquants. <br />

                            fait en sorte de livrer dès le début la feuille de style afin d'avoir le plus vite le rendu définitif. <br />

                            Mais avant qu'une page ne puisse s'afficher, elle doit être analysée par le navigateur. <br />

                            Et si le navigateur tombe sur un contenu bloquant, s'arrêter, le télécharger et le traiter ==>  retarder l'affichage. <br />

                            Il faut donc identifier sur pages tous les types de contenus qui pourrait être bloquants <br />
                            puis reporter leur exécution et chargement après le chargement de la page.

                        </aside>
                    </section>

                    <section>
                        <h2>Descendre le javascript</h2>



                        <aside class="notes">
                            Parmi ces contenus bloquants on trouve fichiers javascripts. <br />

                            Traiter le js dès le début n'est pas utile. <br />
                            Quand le navigateur rencontre une balise script ==> la traiter directement. <br />
                            Et si les script n'est pas inline, il va devoir charger la ressource. <br />
                            pas nécessaire pour le rendu que les interactions ajoutées par javascript soit chargées immédiatement. <br />
                            nettoyé une partie de nos pages pour décaler les appels de fichiers javascripts du head vers le bas de la page.  <br />

                            Attention refactoring pour gérer js inline si vous en avez <br />
                            les scripts qui comptaient sur la présence d’un js chargé immédiatement ne fonctionneront plus et lèveront une erreur. <br />

                            pouvez aussi utiliser l'attribut async pour charger vos fichier javascript. <br />
                            téléchargement et traitement du fichier javascript seront fait en parallèle.  <br />
                            Votre fichier plus bloquant pour rendu de la page, mais rendra indéterminable moment où fichier sera exécuté. <br/>
                            A vous de voir quelle situation vous convient le mieux.  <br />

                            Malheureusement, je n'ai pas de comparatif à vous montrer pour cette optimisation.  <br />
                            Nous avons fait cette modification début 2015 en même temps qu'une refonte totale de la page produit, ce qui fait qu'il est impossible de quantifier l'impact spécifique de cette modification parmi toutes les autres modifications effectuées.
                        </aside>
                    </section>



                    <section>
                        <h2>Auditer les scripts externes</h2>

                        http://requestmap.webperf.tools/render/160321_7E_9be01f45f8c848dbf49d68b97e0ec7d0


                        <aside class="notes">
                            Tracking, retargeting, widget de réseaux sociaux, à un moment donné, on finit par charger sur son site des scripts qu'on n'héberge pas ou sur lesquels nous n'avons pas la main. Et bien sûr un jour arrive où ces scripts tombent, et s'ils sont chargés en synchrone, il faut attendre le timeout navigateur pour que le reste de la page finisse par se charger.

                            Pour évitez ça, auditez, regardez ce qui est chargé, quand et de quelle manière.

                            Voici un graphique représentant les dépendances de notre fiche produit effectué sur webperftools.

                            On voit très bien que la moitié des dépendances, la partie sur la droite, n'est là qu'à cause d'un seul script. Il faut donc faire attention à ce que ce script, s'il ne peut plus être chargé ne fasse pas tomber notre page. Vous pouvez d'ailleurs tester cela dans webpagetest en indiquant dans la configuration SPOF les domaines que vous souhaitez ne pas pouvoir charger.

                            Évitez de charger ces contenus de manière bloquantes, et décalez les chargements plus tard, en les chargeant en asynchrone par exemple.

                            Nous avons également mis l'accent sur la qualité de ces ressources externes. Tout ce que je vous ai dit plus tôt sur la compression des contenus, le cache, etc. n'est parfois pas mis en place sur ces scripts partenaires.

                            Donc regardez bien  ce que vous avez sur vos sites, lisez bien les documents d'intégration de ces scripts qui vous en diront suffisament long sur la qualité technique du module.
                            Et n'hésitez pas à leur remonter ces problèmes pour qu'ils fassent le nécessaire : ça sera bénéfique pour eux et surtout pour vous.

                            Pour terminer, ces scripts sont là souvent pour des raisons de business et il faut être conscient qu'ils ont quand même un coût technique.

                            Pour comparer entre decitre.fr et une de nos marques blanches qui est sur la même plateforme, mais avec nettement moins de ces scripts externe, on a un delta de près d'une seconde sur le temps de chargement global entre les deux sites.
                        </aside>
                    </section>




                    <section>
                        <h2>Paralléliser les chargements des images</h2>

                        <aside class="notes">
                            Homepage (création édito, visuels produits, images dans la CSS) + 50 images utilisées sur la page.
                            FP quarantaine. Les images sont le type de ressource le + appelé <br/>
                            HTTP 1, navigateur peut paralléliser les appels, mais limite de 6 connexions/domaine. Comment détourner limite et améliorer le tmps de chargement ?  <br />
                            Technique pour augmenter la capacité à paralléliser en chargeant sur de nouveaux domaines : domain-sharding <br />
                            www.decitre.fr/mon-image.jpg ==> a.media.decitre.fr/mon-image.jpg (image : media, reste www)
                            Dans notre cas, compte tenu du nombre d'image sur nos pages, 2 sous domaines (a et b) pour augmenter la capacité du navigateur à paralléliser les appels et donc accélérer l'arrivée des images. <br/>


                            Attention : nouveau domaine == 1 résolution DNS à faire. Peut ne pas être rentable. Bien évaluer le nombre de domaine sur lequel on compte effectuer la répartition. <br />
                            Penser au cache et au SEO : toujours sharder sur la même url (chez nous, le magento gére le sharding), il faut donc avoir des règles de sharding qui attribue toujours la même url <br />
                            Post traitement de CSS pour effectuer le sharding lors de la concat. Magento gère les autres images ==> transparent image toujours inclue, peu importe si le mécanisme est actif ou non et peu importe le nombre de domaines de sharding configuré.

                            Exemple de test sans impact final. On voit l'effet dans webpagetest, la parallélisation fonctionne. toutefois il n’y a pas eu gain notable suite à cette mise en place.
                        </aside>
                    </section>

                    <section>
                        <h2>Charger différement les iframe</h2>



                        <aside class="notes">
                            Scripts externes, vidéos, il arrive parfois qu'on ait à sortir de notre à outil à la balise iframe.
                            Et niveau contenu bloquant, c'est pas ce qu'il y a de mieux.

                            Pour ça, nous nous sommes créés un mécanisme de chargement d'iframe asynchrone, activé au domContentLoaded.

                            Cela nous permet de créer l'iframe à ce moment là avec les paramètres que nous souhaitons.
                            Nous pu décaler les chargements de ces contenus qui sont moins prioritaires à plus tard et enlever cette source de blocage de nos pages.

                        </aside>
                    </section>


                </section>

                <section>
                    <section>
                        <h1>Et ensuite ?</h1>
                        <aside class="notes">
                            Voilà pour les modifications que nous avons effectuées.
                            Quels sont les axes d’améliorations que nous avons prévu pour la suite.
                        </aside>
                    </section>

                    <section>
                        <h2>HTTP/2</h2>
                        <aside class="notes">
                            Un des gros chantiers vers lequel on va se pencher dans les prochains mois sera de basculer vers HTTP/2.

                            Pourquoi cette bascule est intéressante ? Après 15 ans de bons et loyaux services, HTTP/2 remplace HTTP 1.1.

                            Parmi les avancées de HTTP/2 on peut citer :
                            Le multiplexage des requêtes : le navigateur n’ouvre plus qu’une seule connexion par domaine, mais il peut désormais envoyer et recevoir plusieurs messages en parallèles.
                            La compression des headers est désormais possible que ce soit pour les réponses ou les requêtes. Cela permet de réduire la bande passante utilisée.
                            Le cache pushing qui permet dans une réponse d'envoyer du contenu lié. Par exemple, lorsque je demande ma page HTML, je peux directement lier la feuille de style.

                            Au final, parmi les points dont je vous ai parlé plus tôt, si on prends le domain sharding ou le keepAlive, voire la concaténation des assets ceux-ci sont rendus inutiles par une implémentation de HTTP/2.
                        </aside>
                    </section>

                    <section>
                        <h2>Autres pistes</h2>
                        <aside class="notes">
                            Ensuite voici quelques uns des points sur lesquels nous pouvons également agir.

                            Une des optimisations possibles serait d'extraire la css critique, c'est à dire la partie de la CSS nécessaire pour afficher le contenu visible au dessus de la ligne de flotaison et l'intégrer dans le HTML.
                            Ainsi on améliore le temps d'affichage de la page.
                            Pour nous, la difficulté c'est d'extraire la partie critique de la css qui réponde aux différents affichages de nos pages.
                            On a trop de contenus différents possibles, ce qui fait que nous avons mis cette optimisation de côté.

                            Il y a également un gros point dont je n'ai pas parlé, et qui va concerner l'optimisation de notre code HTML et CSS.
                            L'object est que le navigateur le traite et en fasse le rendu au plus vite et attendre le taux de rafraichissement de 60fps pour avoir la meilleure fluidité possible à l'écran.
                            Mais c'est une partie sur laquelle nous ne sommes absolument pas penchés.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Autres pistes</h2>
                        <aside class="notes">
                            Ensuite voici quelques uns des points sur lesquels nous pouvons également agir.

                            Une des optimisations possibles serait d'extraire la css critique, c'est à dire la partie de la CSS nécessaire pour afficher le contenu visible au dessus de la ligne de flotaison et l'intégrer dans le HTML.
                            Ainsi on améliore le temps d'affichage de la page.
                            Pour nous, la difficulté c'est d'extraire la partie critique de la css qui réponde aux différents affichages de nos pages.
                            On a trop de contenus différents possibles, ce qui fait que nous avons mis cette optimisation de côté.

                            Il y a également un gros point dont je n'ai pas parlé, et qui va concerner l'optimisation de notre code HTML et CSS.
                            L'object est que le navigateur le traite et en fasse le rendu au plus vite et attendre le taux de rafraichissement de 60fps pour avoir la meilleure fluidité possible à l'écran.
                            Mais c'est une partie sur laquelle nous ne sommes absolument pas penchés.
                        </aside>
                    </section>
                    <section>
                        <h2>Impliquez vos équipes</h2>
                        <aside class="notes">
                            Comme la revue de code, le testing ou pleins d'autres bonnes pratiques, la performance web doit rentrer dans votre culture d'équipe.

                            Mettez des process pour les impacts des modifications, par exemple en pensant à tester vos pages dans un webpagetest après un développement.

                            Ajoutez dans votre intégration continue des mesures régulières pour en suivre l'évolution. Par exemple avec le projet Phantomas qui permet de collecter tout un ensemble de mesures.

                            Chez nous, on utilise gtmetrix. C'est un outil SAAS qui permet de tester plusieurs fois par jours certaines de nos pages critiques. Et on reçoit ensuite toutes les semaines l'évolution des métriques sur ces pages.

                            Enfin, certes en tant qu'équipe de développement, nous avons un impact fort sur le site. Mais nous ne sommes pas les seuls à influer sur le contenu du site.
                            Nous avons aussi chez nous des équipes éditoriales qui interviennent tous les jours sur le site.

                            Donc expliquez-leur et vendez-leur votre culture de la webperf pour qu'ils se l'approprient.
                            Exposez vos métriques et accompagnez les dans l'application de vos process, de manière à ce que tout ceux qui travaillent sur vos sites aient conscience de ces enjeux.
                        </aside>
                    </section>

                    <section>
                        <h2>Tout ça pour quels résultats</h2>
                        <aside class="notes">
                            Durant les deux dernières années, on a de manière itérative, effectué toutes ces modifications, dans l'objectif de charger le minimum, au plus vite en décalant le superflu à plus tard.

                            Plein d’optimisation, mais contrairement aux exemples célèbres cités en intro, il n'y pas eu d’effet sur le business ou sur le SEO.

                            A voir sur le plus long terme, car beaucoup de grosses modifications ont été faites au cours de la dernière année.

                            Mais même si d'un point de vue business, les effets sont mitigées, d'un point de vue de la perception utilisateur, ça reste bénéfique d'avoir un site et des pages qui répondent plus vite.

                            Dans tous les cas, pour moi l'objectif de ce sujet c'était de vous présenter ces aspects.
                            De montrer que même dans une petite équipe on peut travailler sur ces éléments qui pour la plupart sont assez faciles à mettre en oeuvre,
                            Et aussi de vous rappeler qu'il n'y a pas le back dans la vie mais également plein de travail super intéressant à faire de l'autre côté du serveur.
                        </aside>
                    </section>

                </section>

                <section>
                    <h1>Merci pour votre attention</h1>

                    <h3>Des questions ?</h3>
                </section>

            </div>




        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>
